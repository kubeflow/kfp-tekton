diff a/backend/src/apiserver/resource/resource_manager.go b/backend/src/apiserver/resource/resource_manager.go	(rejected hunks)
@@ -21,8 +21,9 @@ import (
 	"io"
 	"strconv"
 
-	workflowapi "github.com/argoproj/argo/pkg/apis/workflow/v1alpha1"
-	workflowclient "github.com/argoproj/argo/pkg/client/clientset/versioned/typed/workflow/v1alpha1"
+	workflowapi "github.com/argoproj/argo-workflows/v3/pkg/apis/workflow/v1alpha1"
+	workflowclient "github.com/argoproj/argo-workflows/v3/pkg/client/clientset/versioned/typed/workflow/v1alpha1"
+	"github.com/argoproj/argo-workflows/v3/workflow/validate"
 	"github.com/cenkalti/backoff"
 	"github.com/golang/glog"
 	api "github.com/kubeflow/pipelines/backend/api/go_client"
@@ -39,6 +40,7 @@ import (
 	"github.com/pkg/errors"
 	"github.com/prometheus/client_golang/prometheus"
 	"github.com/prometheus/client_golang/prometheus/promauto"
+	"google.golang.org/grpc/codes"
 	authorizationv1 "k8s.io/api/authorization/v1"
 	corev1 "k8s.io/api/core/v1"
 	apierrors "k8s.io/apimachinery/pkg/api/errors"
@@ -183,6 +188,7 @@ func (r *ResourceManager) ArchiveExperiment(experimentId string) error {
 		}
 		for _, job := range jobs {
 			_, err = r.getScheduledWorkflowClient(job.Namespace).Patch(
+				ctx,
 				job.Name,
 				types.MergePatchType,
 				[]byte(fmt.Sprintf(`{"spec":{"enabled":%s}}`, strconv.FormatBool(false))))
@@ -324,7 +337,7 @@ func (r *ResourceManager) GetPipelineTemplate(pipelineId string) ([]byte, error)
 	return template, nil
 }
 
-func (r *ResourceManager) CreateRun(apiRun *api.Run) (*model.RunDetail, error) {
+func (r *ResourceManager) CreateRun(ctx context.Context, apiRun *api.Run) (*model.RunDetail, error) {
 	// Get workflow from either of the two places:
 	// (1) raw pipeline manifest in pipeline_spec
 	// (2) pipeline version in resource_references
@@ -390,6 +403,7 @@ func (r *ResourceManager) CreateRun(apiRun *api.Run) (*model.RunDetail, error) {
 	if err != nil {
 		return nil, util.NewInternalServerError(err, "Failed to replace workflow ID")
 	}
+	workflow.SetPodMetadataLabels(util.LabelKeyWorkflowRunId, runId)
 
 	// Marking auto-added artifacts as optional. Otherwise most older workflows will start failing after upgrade to Argo 2.3.
 	// TODO: Fix the components to explicitly declare the artifacts they really output.
@@ -415,8 +429,16 @@ func (r *ResourceManager) CreateRun(apiRun *api.Run) (*model.RunDetail, error) {
 		return nil, err
 	}
 
+	_, err = validate.ValidateWorkflow(nil, nil, workflow.Workflow, validate.ValidateOpts{
+		Lint:                       false,
+		IgnoreEntrypoint:           false,
+		WorkflowTemplateValidation: false, // not used by kubeflow
+	})
+	if err != nil {
+		return nil, util.NewInternalServerError(err, "Failed to validate workflow for (%+v)", workflow.Workflow.Name)
+	}
 	// Create argo workflow CR resource
-	newWorkflow, err := r.getWorkflowClient(namespace).Create(workflow.Get())
+	newWorkflow, err := r.getWorkflowClient(namespace).Create(ctx, workflow.Get(), v1.CreateOptions{})
 	if err != nil {
 		return nil, util.NewInternalServerError(err, "Failed to create a workflow for (%s)", workflow.Name)
 	}
@@ -458,7 +480,7 @@ func (r *ResourceManager) DeleteRun(runID string) error {
 	if err != nil {
 		return util.Wrap(err, "Delete run failed")
 	}
-	err = r.getWorkflowClient(namespace).Delete(runDetail.Name, &v1.DeleteOptions{})
+	err = r.getWorkflowClient(namespace).Delete(ctx, runDetail.Name, v1.DeleteOptions{})
 	if err != nil {
 		// API won't need to delete the workflow CR
 		// once persistent agent sync the state to DB and set TTL for it.
@@ -471,13 +493,37 @@ func (r *ResourceManager) DeleteRun(runID string) error {
 	return nil
 }
 
+func (r *ResourceManager) CreateTask(ctx context.Context, apiTask *api.Task) (*model.Task, error) {
+	uuid, err := r.uuid.NewRandom()
+	if err != nil {
+		return nil, util.NewInternalServerError(err, "Failed to generate task ID.")
+	}
+	id := uuid.String()
+	task := model.Task{
+		UUID:              id,
+		Namespace:         apiTask.Namespace,
+		PipelineName:      apiTask.PipelineName,
+		RunUUID:           apiTask.RunId,
+		MLMDExecutionID:   apiTask.MlmdExecutionID,
+		CreatedTimestamp:  apiTask.CreatedAt.AsTime().Unix(),
+		FinishedTimestamp: apiTask.FinishedAt.AsTime().Unix(),
+		Fingerprint:       apiTask.Fingerprint,
+	}
+	return r.taskStore.CreateTask(&task)
+}
+
+func (r *ResourceManager) ListTasks(filterContext *common.FilterContext,
+	opts *list.Options) (tasks []*model.Task, total_size int, nextPageToken string, err error) {
+	return r.taskStore.ListTasks(filterContext, opts)
+}
+
 func (r *ResourceManager) ListJobs(filterContext *common.FilterContext,
 	opts *list.Options) (jobs []*model.Job, total_size int, nextPageToken string, err error) {
 	return r.jobStore.ListJobs(filterContext, opts)
 }
 
 // TerminateWorkflow terminates a workflow by setting its activeDeadlineSeconds to 0
-func TerminateWorkflow(wfClient workflowclient.WorkflowInterface, name string) error {
+func TerminateWorkflow(ctx context.Context, wfClient workflowclient.WorkflowInterface, name string) error {
 	patchObj := map[string]interface{}{
 		"spec": map[string]interface{}{
 			"activeDeadlineSeconds": 0,
@@ -490,7 +536,7 @@ func TerminateWorkflow(wfClient workflowclient.WorkflowInterface, name string) e
 	}
 
 	var operation = func() error {
-		_, err = wfClient.Patch(name, types.MergePatchType, patch)
+		_, err = wfClient.Patch(ctx, name, types.MergePatchType, patch, v1.PatchOptions{})
 		return err
 	}
 	var backoffPolicy = backoff.WithMaxRetries(backoff.NewConstantBackOff(100), 10)
@@ -544,16 +590,16 @@ func (r *ResourceManager) RetryRun(runId string) error {
 		return util.Wrap(err, "Retry run failed.")
 	}
 
-	if err = deletePods(r.k8sCoreClient, podsToDelete, namespace); err != nil {
+	if err = deletePods(ctx, r.k8sCoreClient, podsToDelete, namespace); err != nil {
 		return util.NewInternalServerError(err, "Retry run failed. Failed to clean up the failed pods from previous run.")
 	}
 
 	// First try to update workflow
-	updateError := r.updateWorkflow(newWorkflow, namespace)
+	updateError := r.updateWorkflow(ctx, newWorkflow, namespace)
 	if updateError != nil {
 		// Remove resource version
 		newWorkflow.ResourceVersion = ""
-		newCreatedWorkflow, createError := r.getWorkflowClient(namespace).Create(newWorkflow.Workflow)
+		newCreatedWorkflow, createError := r.getWorkflowClient(namespace).Create(ctx, newWorkflow.Workflow, v1.CreateOptions{})
 		if createError != nil {
 			return util.NewInternalServerError(createError,
 				"Retry run failed. Failed to create or update the run. Update Error: %s, Create Error: %s",
@@ -582,7 +628,7 @@ func (r *ResourceManager) ReadLog(runId string, nodeId string, follow bool, dst
 	return err
 }
 
-func (r *ResourceManager) readRunLogFromPod(run *model.RunDetail, nodeId string, follow bool, dst io.Writer) error {
+func (r *ResourceManager) readRunLogFromPod(ctx context.Context, run *model.RunDetail, nodeId string, follow bool, dst io.Writer) error {
 	logOptions := corev1.PodLogOptions{
 		Container:  "main",
 		Timestamps: false,
@@ -590,7 +636,7 @@ func (r *ResourceManager) readRunLogFromPod(run *model.RunDetail, nodeId string,
 	}
 
 	req := r.k8sCoreClient.PodClient(run.Namespace).GetLogs(nodeId, &logOptions)
-	podLogs, err := req.Stream()
+	podLogs, err := req.Stream(ctx)
 	if err != nil {
 		if !apierrors.IsNotFound(err) {
 			glog.Errorf("Failed to access Pod log: %v", err)
@@ -636,15 +682,15 @@ func (r *ResourceManager) readRunLogFromArchive(run *model.RunDetail, nodeId str
 	return nil
 }
 
-func (r *ResourceManager) updateWorkflow(newWorkflow *util.Workflow, namespace string) error {
+func (r *ResourceManager) updateWorkflow(ctx context.Context, newWorkflow *util.Workflow, namespace string) error {
 	// If fail to get the workflow, return error.
-	latestWorkflow, err := r.getWorkflowClient(namespace).Get(newWorkflow.Name, v1.GetOptions{})
+	latestWorkflow, err := r.getWorkflowClient(namespace).Get(ctx, newWorkflow.Name, v1.GetOptions{})
 	if err != nil {
 		return err
 	}
 	// Update the workflow's resource version to latest.
 	newWorkflow.ResourceVersion = latestWorkflow.ResourceVersion
-	_, err = r.getWorkflowClient(namespace).Update(newWorkflow.Workflow)
+	_, err = r.getWorkflowClient(namespace).Update(ctx, newWorkflow.Workflow, v1.UpdateOptions{})
 	return err
 }
 
@@ -728,7 +774,7 @@ func (r *ResourceManager) CreateJob(apiJob *api.Job) (*model.Job, error) {
 		return nil, err
 	}
 
-	newScheduledWorkflow, err := r.getScheduledWorkflowClient(namespace).Create(scheduledWorkflow)
+	newScheduledWorkflow, err := r.getScheduledWorkflowClient(namespace).Create(ctx, scheduledWorkflow)
 	if err != nil {
 		return nil, util.NewInternalServerError(err, "Failed to create a scheduled workflow for (%s)", scheduledWorkflow.Name)
 	}
@@ -759,6 +805,7 @@ func (r *ResourceManager) EnableJob(jobID string, enabled bool) error {
 	}
 
 	_, err = r.getScheduledWorkflowClient(job.Namespace).Patch(
+		ctx,
 		job.Name,
 		types.MergePatchType,
 		[]byte(fmt.Sprintf(`{"spec":{"enabled":%s}}`, strconv.FormatBool(enabled))))
@@ -777,13 +824,13 @@ func (r *ResourceManager) EnableJob(jobID string, enabled bool) error {
 	return nil
 }
 
-func (r *ResourceManager) DeleteJob(jobID string) error {
+func (r *ResourceManager) DeleteJob(ctx context.Context, jobID string) error {
 	job, err := r.jobStore.GetJob(jobID)
 	if err != nil {
 		return util.Wrap(err, "Delete job failed")
 	}
 
-	err = r.getScheduledWorkflowClient(job.Namespace).Delete(job.Name, &v1.DeleteOptions{})
+	err = r.getScheduledWorkflowClient(job.Namespace).Delete(ctx, job.Name, &v1.DeleteOptions{})
 	if err != nil {
 		if !util.IsNotFound(err) {
 			// For any error other than NotFound
@@ -816,7 +863,7 @@ func (r *ResourceManager) ReportWorkflowResource(workflow *util.Workflow) error
 
 	if workflow.PersistedFinalState() {
 		// If workflow's final state has being persisted, the workflow should be garbage collected.
-		err := r.getWorkflowClient(workflow.Namespace).Delete(workflow.Name, &v1.DeleteOptions{})
+		err := r.getWorkflowClient(workflow.Namespace).Delete(ctx, workflow.Name, v1.DeleteOptions{})
 		if err != nil {
 			// A fix for kubeflow/pipelines#4484, persistence agent might have an outdated item in its workqueue, so it will
 			// report workflows that no longer exist. It's important to return a not found error, so that persistence
@@ -918,7 +983,7 @@ func (r *ResourceManager) ReportWorkflowResource(workflow *util.Workflow) error
 }
 
 // AddWorkflowLabel add label for a workflow
-func AddWorkflowLabel(wfClient workflowclient.WorkflowInterface, name string, labelKey string, labelValue string) error {
+func AddWorkflowLabel(ctx context.Context, wfClient workflowclient.WorkflowInterface, name string, labelKey string, labelValue string) error {
 	patchObj := map[string]interface{}{
 		"metadata": map[string]interface{}{
 			"labels": map[string]interface{}{
@@ -933,7 +998,7 @@ func AddWorkflowLabel(wfClient workflowclient.WorkflowInterface, name string, la
 	}
 
 	var operation = func() error {
-		_, err = wfClient.Patch(name, types.MergePatchType, patch)
+		_, err = wfClient.Patch(ctx, name, types.MergePatchType, patch, v1.PatchOptions{})
 		return err
 	}
 	var backoffPolicy = backoff.WithMaxRetries(backoff.NewConstantBackOff(100), 10)
@@ -948,13 +1013,13 @@ func (r *ResourceManager) ReportScheduledWorkflowResource(swf *util.ScheduledWor
 // checkJobExist The Kubernetes API doesn't support CRUD by UID. This method
 // retrieve the job metadata from the database, then retrieve the CR
 // using the job name, and compare the given job id is same as the CR.
-func (r *ResourceManager) checkJobExist(jobID string) (*model.Job, error) {
+func (r *ResourceManager) checkJobExist(ctx context.Context, jobID string) (*model.Job, error) {
 	job, err := r.jobStore.GetJob(jobID)
 	if err != nil {
 		return nil, util.Wrap(err, "Check job exist failed")
 	}
 
-	scheduledWorkflow, err := r.getScheduledWorkflowClient(job.Namespace).Get(job.Name, v1.GetOptions{})
+	scheduledWorkflow, err := r.getScheduledWorkflowClient(job.Namespace).Get(ctx, job.Name, v1.GetOptions{})
 	if err != nil {
 		return nil, util.NewInternalServerError(err, "Check job exist failed")
 	}
@@ -1252,14 +1329,16 @@ func (r *ResourceManager) AuthenticateRequest(ctx context.Context) (string, erro
 	return "", utilerrors.NewAggregate(errlist)
 }
 
-func (r *ResourceManager) IsRequestAuthorized(userIdentity string, resourceAttributes *authorizationv1.ResourceAttributes) error {
+func (r *ResourceManager) IsRequestAuthorized(ctx context.Context, userIdentity string, resourceAttributes *authorizationv1.ResourceAttributes) error {
 	result, err := r.subjectAccessReviewClient.Create(
+		ctx,
 		&authorizationv1.SubjectAccessReview{
 			Spec: authorizationv1.SubjectAccessReviewSpec{
 				ResourceAttributes: resourceAttributes,
 				User:               userIdentity,
 			},
 		},
+		v1.CreateOptions{},
 	)
 	if err != nil {
 		return util.NewInternalServerError(
